
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MaidenHQ — Focus Timer with Focus Fox</title>

<link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital,wght@0,400;0,700;1,400;1,700&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

<style>
:root{
  --page-beige: #FAF7EA;
  --accent-blue: #005DB8;
  --pink-shadow: #f762d0;
  --white-shadow: #fff5f9;
  --frame-size: 180px; /* change to 32px if you exported 32x32 sprites */
   --segments: 20;            /* change to 10 / 20 / 40 for different resolution */
  --size: 1rem;             /* size of each pixel block (square) */
  --gap: 2px;               /* gap between blocks to keep pixel feel */
}

/* base */
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--page-beige);color:var(--accent-blue)}
body{font-family:'Poppins',sans-serif;display:flex;align-items:center;justify-content:center;padding:36px}

/* card */
.card{
  width:820px; max-width:94vw;
  border-radius:12px;
  padding:28px;
  border:3px solid var(--accent-blue);
  box-shadow: 10px 10px 0 var(--pink-shadow);
  display:flex;flex-direction:column;align-items:center;
  background:transparent;
}

/* header */
.h-title{
  font-family:'Instrument Serif',serif;
  font-size:8rem;
  margin:0;
  color:var(--accent-blue);
  text-align:center;
  line-height:0.9;
  letter-spacing:-0.3rem;
}
.h-sub{font-family:'Instrument Serif',serif;font-size:12px;color:var(--accent-blue);margin-top:6px;text-align:center}

/* layout */
.stack{display:flex;flex-direction:column;align-items:center;gap:18px;margin-top:18px;width:100%}

/* fox */
.fox-sprite {
  width: var(--frame-size);
  height: var(--frame-size);
  position: relative; 
  image-rendering: pixelated;
  background-repeat: no-repeat;
  background-size: contain;
  margin: 0 auto;
}

.fox-sprite img {
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
  position: absolute;
  top: 0; left: 0;
  opacity: 0;                 /* start invisible */
  transition: opacity 0.22s ease;  /* smooth fade */
  display: none;
}
.fox-sprite img.active {
  display: block;
  opacity: 1;                 /* fade in when active */

}
  

/* fox line */
.fox-line { margin-top:10px; font-family:'Instrument Serif',serif; font-size:1.5rem; color:var(--accent-blue); text-align:center; transition:opacity .32s ease; opacity:1; }

/* Pixel progress bar */
/* Pixel progress bar updated to align horizontal */
/* Pixel progress bar updated to align horizontal (use explicit template) */
#pixelBar{
  display: grid;
  grid-template-columns: repeat(var(--segments), var(--size));
  gap: var(--gap);
  padding: 6px;
  border-radius: 6px;
  background: transparent;
  image-rendering: pixelated;
  transform: translateZ(0);
  justify-content: center;
  max-width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}


 

/* single cell */
#pixelBar .cell{
  width: var(--size);
  height: var(--size);
  background: rgba(10,10,10,0.03); /* empty color (subtle) */
  border: 1px solid rgba(0,0,0,0.04); /* slight bevel to read blocks as separate pixels */
  box-sizing: border-box;
  transition: background 160ms linear, box-shadow 160ms linear;
  image-rendering: pixelated;
  border-radius: 0px; /* blocky */
  display:inline-block;
  vertical-align: middle;
}

/* filled cell (brand blue) */
#pixelBar .cell.filled{
  background: var(--accent-blue); /* brand blue */
  border-color: rgba(0,0,0,0.03);
  box-shadow: 0 0 0 0 rgba(0,0,0,0);
}

/* subtle accent shadow for filled — very light */
#pixelBar .cell.filled::after{
  content: "";
  display:block;
  width:100%; height:100%;
  box-shadow: 3px 3px 0 #f762d0;
  opacity: 0.5;
  pointer-events:none;
}



  

/* timer text */
.timer-number{ font-family:'Instrument Serif',serif; font-size:44px; color:var(--accent-blue); font-weight:700; margin-top:6px; text-align:center}
.small-meta{ font-family:'Poppins',sans-serif; font-size:13px; color:rgba(0,0,0,0.45); margin-top:4px; text-align:center }
/* hide the second percent under session label (visual only) */
.small-meta .percent { display: none; }


  
/* main action */
.main-action{
  width:360px; max-width:92%;
  height:56px;border-radius:10px;border:none;background:var(--accent-blue);
  color:#fff;display:flex;align-items:center;justify-content:center;gap:10px;
  font-weight:700;font-size:18px;cursor:pointer;
  box-shadow:6px 6px 0 var(--pink-shadow), -3px -3px 0 var(--white-shadow);
  transition:box-shadow .12s ease, transform .12s ease;font-family:'Poppins',sans-serif;
}
.main-action svg{ width:16px;height:16px; flex-shrink:0; transform:none; }
.main-action:hover{ box-shadow:3px 3px 0 var(--pink-shadow), -1px -1px 0 var(--white-shadow); transform:translateY(-2px) }

/* controls */
.controls-row{ display:flex; gap:14px; align-items:center; justify-content:center; margin-top:8px }
.icon-circle{ width:48px;height:48px;border-radius:50%; background:var(--page-beige); border:2px solid var(--accent-blue); display:inline-flex;align-items:center;justify-content:center; box-shadow:2px 2px 0 var(--pink-shadow), -3px -3px 0 var(--white-shadow); cursor:pointer; transition: box-shadow .12s ease, transform .12s ease; }
.icon-svg{ width:18px;height:18px; fill:var(--accent-blue) }

 
/* settings panel with smooth transition */
.settings-panel{
  width:100%;
  max-width:620px;
  overflow:hidden;
  transition:max-height 360ms cubic-bezier(.2,.9,.3,1), opacity 260ms ease, padding 260ms ease;
  max-height:0;
  opacity:0;
  padding:0 12px;
  border-radius:10px;
  border: 2px solid var(--accent-blue);
  margin-top:10px;
  position:relative;
  z-index:1;
}
.settings-panel.open{ max-height:220px; opacity:1; padding:12px; }

/* settings content */
.settings-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:center}
.settings-label{font-family:'Instrument Serif',serif;font-size:14px;color:var(--accent-blue); width:56px; text-align:right}
.settings-input{ width:72px;padding:8px;border-radius:10px;border:1px solid #eee;text-align:center;font-weight:700;color:var(--accent-blue); font-family:'Poppins',sans-serif} 

/* reduced motion */
@media (prefers-reduced-motion: reduce) {
  .fox-sprite { transition: none !important; animation: none !important; }
}

/* ---------- Responsive adjustments ---------- */
/* general narrow screens */
@media (max-width: 900px) {
  .card { padding:20px; width:720px; }
  :root { --frame-size: 140px; --size: 0.9rem; --gap: 4px; }
  .h-title { font-size:5rem; letter-spacing:-0.16rem; }
  .timer-number { font-size:36px; }
  .main-action { width:300px; height:50px; font-size:16px; }
  .controls-row { gap:10px; }
}

/* small phones */
@media (max-width: 480px) {
  body { padding:18px; }
  .card { width:100%; padding:16px; box-shadow: none; }
  :root { --frame-size: 110px; --size: 0.8rem; --gap: 3px; --segments: 14; }
  .h-title { font-size:2.4rem; letter-spacing:-0.06rem; line-height:1; }
  .h-sub { font-size:13px; }
  .timer-number { font-size:34px; }
  .main-action { width:220px; height:46px; font-size:15px; }
  .controls-row { gap:8px; }
  /* make fox slightly smaller and centered */
  .fox-sprite { width: var(--frame-size); height: var(--frame-size); margin-bottom: 6px; }
  /* if you want to hide the fox completely on very small screens, uncomment: */
  /* .fox-sprite { display:none; } */
  /* Pixel bar: ensure it stays horizontal and fits */
  #pixelBar { overflow-x:auto; -webkit-overflow-scrolling: touch; max-width: 100%; padding: 4px; }
  #pixelBar .cell { width: var(--size); height: var(--size); }
  .small-meta { font-size:12px; }
}
  
</style>
</head>
<body>
  <div class="card" role="application" aria-label="MaidenHQ Focus Timer">
    <div style="text-align:center">
      <div class="h-title">Focus Timer</div>
      <div class="h-sub">Pomodoro with Focus Fox</div>
    </div>

    <main class="stack" aria-live="polite">
      <!-- FOX -->
      <div id="fox" class="fox-sprite" aria-hidden="true"></div>
      <div id="foxLine" class="fox-line">Fox is waiting…</div>

      <!-- Pixel progress bar -->
<div id="pixelBarWrap" aria-hidden="false" style="margin-top:12px; text-align:center;">
  <div id="pixelBar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Session progress"></div>
  <div id="pixelBarText" style="font-family: Poppins, sans-serif; font-size:12px; color:rgba(0,0,0,0.45); margin-top:6px;">
    0%
  </div>
</div>


      <!-- TIME -->
      <div class="timer-number" id="timeDisplay">25:00</div>
      <div class="small-meta">
        <div id="sessionLabel">Session 0</div>
        <div class="percent" id="percentLabel">0%</div>
      </div>

      <!-- ACTION -->
      <button id="mainAction" class="main-action" aria-pressed="false" aria-label="Start/Pause">
        <svg id="mainIcon" viewBox="0 0 24 24" fill="#fff"><path d="M8 5v14l11-7z"/></svg>
        <span id="mainLabel">Start</span>
      </button>

      <!-- controls -->
      <div class="controls-row">
        <button id="skipBtn" class="icon-circle" title="Skip"><svg class="icon-svg" viewBox="0 0 24 24"><path d="M4 18v-12l8 6-8 6zm9 0V6h2v12h-2z"/></svg></button>
        <button id="resetBtn" class="icon-circle" title="Reset"><svg class="icon-svg" viewBox="0 0 24 24"><path d="M12 6V3L8 7l4 4V8c2.76 0 5 2.24 5 5 0 .65-.13 1.27-.36 1.84l1.46 1.46C19.82 15.03 20 14.03 20 13c0-4.42-3.58-8-8-8z"/></svg></button>
        <button id="settingsBtn" class="icon-circle" title="Settings" aria-label="Settings" aria-expanded="false" aria-controls="settingsPanel">
  <svg class="icon-svg" viewBox="0 0 24 24" aria-hidden>
    <path d="M19.14 12.94a7.14 7.14 0 0 0 0-1.88l2.03-1.58a.5.5 0 0 0 .12-.63l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.02 7.02 0 0 0-1.6-.93l-.36-2.54A.5.5 0 0 0 14.1 2h-3.2a.5.5 0 0 0-.49.42l-.36 2.54a7.02 7.02 0 0 0-1.6.93L5.06 5.9a.5.5 0 0 0-.6.22L2.54 9.44a.5.5 0 0 0 .12.63L4.69 11.6a7.14 7.14 0 0 0 0 1.88L2.66 15.06a.5.5 0 0 0-.12.63l1.92 3.32c.14.24.44.34.69.22l2.39-.96c.5.36 1.04.66 1.6.93l.36 2.54c.05.26.26.43.49.43h3.2c.23 0 .44-.17.49-.43l.36-2.54c.56-.27 1.1-.57 1.6-.93l2.39.96c.25.12.55.02.69-.22l1.92-3.32a.5.5 0 0 0-.12-.63l-2.03-1.58zM12 15.5A3.5 3.5 0 1 1 12 8.5a3.5 3.5 0 0 1 0 7z"/>
  </svg>
</button>
      </div>
              <!-- Settings panel -->
<div id="settingsPanel" class="settings-panel" aria-hidden="true">
  <div class="settings-row">
    <div class="settings-label">Work</div>
    <input id="workInput" class="settings-input" type="number" min="1" value="25" />
    <div class="settings-label">Short</div>
    <input id="shortInput" class="settings-input" type="number" min="1" value="5" />
    <div class="settings-label">Long</div>
    <input id="longInput" class="settings-input" type="number" min="1" value="15" />
  </div>
</div>

      <div class="footer">Designed by MaidenHQ — calm focus, small wins</div>
    </main>
  </div>

<script>
/*
  Single-file integrated timer + Focus Fox
  -------------------------
  EXPECTED SPRITE FILES (place in "sprites/" next to this file):
  Neutral:
    sprites/neutral_base.png
    sprites/neutral_blink.png
    sprites/neutral_ear.png
    sprites/neutral_tail.png
  Alert (work):
    sprites/alert_base.png
    sprites/alert_blink.png
    sprites/alert_ear.png
    sprites/alert_tail1.png
    sprites/alert_tail2.png
  Stretch (short break):
    sprites/stretch_base.png
    sprites/stretch_tail.png
    sprites/stretch_squint.png
    sprites/stretch_ear.png
  Nap (long break):
    sprites/nap_base.png
    sprites/nap_breathe.png
    sprites/nap_blink.png
    sprites/nap_ear.png
    sprites/nap_tail.png
*/

document.addEventListener('DOMContentLoaded', ()=>{

  /* ---------- DOM refs ---------- */
  const foxEl = document.getElementById('fox');
  const foxLine = document.getElementById('foxLine');
  const timeDisplay = document.getElementById('timeDisplay');
  const sessionLabel = document.getElementById('sessionLabel');
  const percentLabel = document.getElementById('percentLabel');
  const mainAction = document.getElementById('mainAction');
  const mainLabel = document.getElementById('mainLabel');
  const mainIcon = document.getElementById('mainIcon');
  const skipBtn = document.getElementById('skipBtn');
  const resetBtn = document.getElementById('resetBtn');
  const settingsBtn = document.getElementById('settingsBtn');
const settingsPanel = document.getElementById('settingsPanel');
const workInput = document.getElementById('workInput');
const shortInput = document.getElementById('shortInput');
const longInput = document.getElementById('longInput');

  /* ---------- Fox frames and lines (naming convention) ---------- */
  const foxFrames = {
    neutral: {
      base: "sprites/neutral_base.png",
      blink: "sprites/neutral_blink.png",
      ear: "sprites/neutral_ear.png",
      tail: "sprites/neutral_tail.png",
      lines: ["I’m here when you are.","Fox is waiting patiently.","Ready when you’re ready."]
    },
    alert: {
      base: "sprites/alert_base.png",
      blink: "sprites/alert_blink.png",
      ear: "sprites/alert_ear.png",
      tail: "sprites/alert_tail.png",
      linesStart: ["Sharp as a fox. Let’s focus.","All ears, let’s hunt down this task."],
      linesMid: ["Stay in the hunt. Don’t wander.","Halfway there — tail still wagging."],
      linesEnd: ["Eyes on the finish line.","Almost there, don’t let go."]
    },
    stretch: {
      base: "sprites/stretch_base.png",
      tail: "sprites/stretch_tail.png",
      squint: "sprites/stretch_squint.png",
      ear: "sprites/stretch_ear.png",
      lines: ["Fox is stretching, you should too.","Shake it out, small break for small wins."]
    },
    nap: {
      base: "sprites/nap_base.png",
      breathe: "sprites/nap_breathe.png",
      blink: "sprites/nap_blink.png",
      ear: "sprites/nap_ear.png",
      tail: "sprites/nap_tail.png",
      lines: ["Time’s up. I’m off to nap — you too.","Curling up… see you soon."]
    }
  };

  /* ---------- tiny helpers ---------- */
 function setFox(img){
  const all = foxEl.querySelectorAll("img");
  all.forEach(el => el.classList.remove("active"));
  const target = foxEl.querySelector(`img[data-src="${img}"]`);
  if(target) target.classList.add("active");
}

  function setLine(text){
  foxLine.style.opacity = 0;
  setTimeout(()=>{
    foxLine.textContent = text;
    foxLine.style.opacity = 1;
  }, 320); // matches CSS transition
}

  function random(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  /* ---------- animation timers ---------- */
  let microTimers = [];
// robust clear of any scheduled micro timers (intervals + timeouts)
function clearMicro(){
  try{
    if(!microTimers || microTimers.length === 0) {
      microTimers = [];
      return;
    }
    // clear everything in the array (works for both interval and timeout IDs)
    microTimers.forEach(id => {
      try { clearInterval(id); } catch(e){}
      try { clearTimeout(id); } catch(e){}
    });
  } finally {
    microTimers = [];
  }
}



  /* Start micro animations appropriate to state */
 function startMicro(stateName){
  clearMicro();

  if(stateName === 'neutral'){
    // occasional blink ~12s
    const id = setInterval(()=>{
      const t = setTimeout(()=> setFox(foxFrames.neutral.base), 260);
      setFox(foxFrames.neutral.blink);
      microTimers.push(t);
    }, 12000);
    microTimers.push(id);

  } else if(stateName === 'alert'){
    // mixed micro actions approx every 8-12s
    const id = setInterval(()=>{
      const r = Math.random();
      if(r < 0.4){
        // blink
        setFox(foxFrames.alert.blink);
        const t = setTimeout(()=> setFox(foxFrames.alert.base), 220);
        microTimers.push(t);
      } else if(r < 0.75){
        // tail twitch (single frame)
        setFox(foxFrames.alert.tail);
        const t = setTimeout(()=> setFox(foxFrames.alert.base), 260);
        microTimers.push(t);
      } else {
        // ear twitch
        setFox(foxFrames.alert.ear);
        const t = setTimeout(()=> setFox(foxFrames.alert.base), 240);
        microTimers.push(t);
      }
    }, 10000 + Math.floor(Math.random()*4000));
    microTimers.push(id);

  } else if(stateName === 'stretch'){
    // occasional small tail twitch
    const id = setInterval(()=>{
      setFox(foxFrames.stretch.tail);
      const t = setTimeout(()=> setFox(foxFrames.stretch.base), 260);
      microTimers.push(t);
    }, 8000);
    microTimers.push(id);

  } else if(stateName === 'nap'){
    // breathing loop every ~1.5s and extra occasional events
    let breathToggle = false;
    const id = setInterval(()=>{
      breathToggle = !breathToggle;
      setFox(breathToggle ? foxFrames.nap.breathe : foxFrames.nap.base);
    }, 1500);
    microTimers.push(id);

    // extras: occasional blink/ear/tail every ~9-17s
    const extraId = setInterval(()=>{
      const r = Math.random();
      if(r < 0.12){
        setFox(foxFrames.nap.blink);
        const t = setTimeout(()=> setFox(foxFrames.nap.base), 260);
        microTimers.push(t);
      } else if(r < 0.22){
        setFox(foxFrames.nap.ear);
        const t = setTimeout(()=> setFox(foxFrames.nap.base), 260);
        microTimers.push(t);
      } else if(r < 0.32){
        setFox(foxFrames.nap.tail);
        const t = setTimeout(()=> setFox(foxFrames.nap.base), 260);
        microTimers.push(t);
      }
    }, 9000 + Math.floor(Math.random()*8000));
    microTimers.push(extraId);
  }
}


  function stopAllMicro(){
    clearMicro();
  }

  /* ---------- state + milestone flags ---------- */
  const timerState = {
    running: false,
    mode: 'work', // 'work' | 'short' | 'long' (affects durations)
    workMin: 25,
    shortMin: 5,
    longMin: 15,
    remaining: 25 * 60,
    sessionCount: 0,
    intervalId: null
  };

  let milestoneFired = { mid:false, end:false };

  function resetMilestones(){ milestoneFired = { mid:false, end:false }; }

  /* ---------- set fox state (high-level) ---------- */
  function setFoxState(stateName){
    stopAllMicro();
    if(stateName === 'neutral'){
      setFox(foxFrames.neutral.base);
      setLine(random(foxFrames.neutral.lines));
    } else if(stateName === 'alert'){
      setFox(foxFrames.alert.base);
      setLine(random(foxFrames.alert.linesStart));
    } else if(stateName === 'stretch'){
      setFox(foxFrames.stretch.base);
      setLine(random(foxFrames.stretch.lines));
    } else if(stateName === 'nap'){
      setFox(foxFrames.nap.base);
      setLine(random(foxFrames.nap.lines));
    }
    startMicro(stateName);
  }

  /* ---------- milestone handler ---------- */
  function onMilestone(pct){
    // only relevant during work
    if(timerState.mode !== 'work') return;

    if(pct >= 50 && !milestoneFired.mid){
      milestoneFired.mid = true;
      setLine(random(foxFrames.alert.linesMid));
      // small ear twitch
      setFox(foxFrames.alert.ear);
      const t = setTimeout(()=> setFox(foxFrames.alert.base), 300);
      microTimers.push(t);

    }

    if(pct >= 90 && !milestoneFired.end){
      milestoneFired.end = true;
      setLine(random(foxFrames.alert.linesEnd));
      // blink
      setFox(foxFrames.alert.blink);
      const t = setTimeout(()=> setFox(foxFrames.alert.base), 300);
      microTimers.push(t);

    }
  }

  /* ---------- timer display / logic ---------- */
  function loadInputsDefaults(){
    // uses defaults already in timerState (we can extend if inputs exist)
    timerState.workMin = Math.max(1, timerState.workMin);
    timerState.shortMin = Math.max(1, timerState.shortMin);
    timerState.longMin = Math.max(1, timerState.longMin);
  }

/* ---------- Pixel progress bar logic (improved) ---------- */
/* Call with explicit values if you want to override; otherwise it
   will use the CSS --segments / --size / --gap already defined in :root. */
function buildPixelBar(segs, sizePx, gapPx){
  const bar = document.getElementById('pixelBar');
  if(!bar) return;

  // Read CSS defaults from computed styles if arguments are omitted
  const cs = getComputedStyle(document.documentElement);
  const rootSegments = parseInt(cs.getPropertyValue('--segments')) || 20;
  const rootSize = cs.getPropertyValue('--size') ? parseInt(cs.getPropertyValue('--size')) : null;
  const rootGap  = cs.getPropertyValue('--gap')  ? parseInt(cs.getPropertyValue('--gap'))  : null;

  const useSegs = (typeof segs === 'number') ? Math.max(1, Math.round(segs)) : rootSegments;
  const useSize = (typeof sizePx === 'number') ? Math.max(4, Math.round(sizePx)) : (rootSize || 10);
  const useGap  = (typeof gapPx === 'number')  ? Math.max(0, Math.round(gapPx))  : (rootGap  || 4);

  // update CSS custom props so CSS-driven sizing matches
  bar.style.setProperty('--segments', String(useSegs));
  bar.style.setProperty('--size', `${useSize}px`);
  bar.style.setProperty('--gap', `${useGap}px`);

  // avoid rebuilding if same count already built
  if(bar.dataset.built === String(useSegs)) return;

  bar.innerHTML = '';
  for(let i=0;i<useSegs;i++){
    const d = document.createElement('div');
    d.className = 'cell';
    d.setAttribute('data-index', i);
    bar.appendChild(d);
  }
  bar.dataset.built = String(useSegs);
}

/* Set progress; reads --segments from computed style (robust) */
function setPixelProgress(pct){
  const bar = document.getElementById('pixelBar');
  const text = document.getElementById('pixelBarText');
  if(!bar) return;
  pct = Math.max(0, Math.min(100, Math.round(pct)));

  // prefer computed style (works even if you changed --segments in CSS)
  const cs = getComputedStyle(bar);
  const segsFromCss = parseInt(cs.getPropertyValue('--segments')) || parseInt(bar.dataset.built) || 20;
  const segs = Math.max(1, segsFromCss);

  const filled = Math.round((pct/100) * segs);
  const cells = bar.querySelectorAll('.cell');
  // if cells length doesn't match segs, rebuild to ensure parity
  if(cells.length !== segs){
    buildPixelBar(segs, parseInt(cs.getPropertyValue('--size')) || undefined, parseInt(cs.getPropertyValue('--gap')) || undefined);
  }
  bar.querySelectorAll('.cell').forEach((c, idx) => {
    if(idx < filled) c.classList.add('filled'); else c.classList.remove('filled');
  });

  bar.setAttribute('aria-valuenow', String(pct));
  if(text) text.textContent = `${pct}%`;
}

// ---------- adaptive pixel bar that understands rem/em/px ----------
function toPx(valueStr){
  // valueStr might be like "1.2rem", "15px", "1.5", or "1.2em"
  if(!valueStr) return NaN;
  valueStr = String(valueStr).trim();
  const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;

  if(valueStr.endsWith('px')) return parseFloat(valueStr);
  if(valueStr.endsWith('rem')) return parseFloat(valueStr) * rootFontSize;
  if(valueStr.endsWith('em'))  return parseFloat(valueStr) * rootFontSize; // we assume root context is fine
  // fallback: numeric value with no unit -> assume px
  const n = parseFloat(valueStr);
  return isNaN(n) ? NaN : n;
}

function adaptiveBuildPixelBar(minSegs = 8, maxSegs = 60){
  const bar = document.getElementById('pixelBar');
  const card = document.querySelector('.card') || document.body;
  if(!bar || !card) return;

  const rootStyles = getComputedStyle(document.documentElement);
  // read CSS vars (may be in rem/em/px)
  const sizeRaw = rootStyles.getPropertyValue('--size') || rootStyles.getPropertyValue('--size ').trim();
  const gapRaw  = rootStyles.getPropertyValue('--gap')  || rootStyles.getPropertyValue('--gap ').trim();

  const sizePx = toPx(sizeRaw) || 12; // fallback px
  const gapPx  = toPx(gapRaw)  || 4;

  // available width (leave some breathing room for paddings & controls)
  const computedAvailable = Math.max(120, card.clientWidth - 120);
  // If you prefer to measure the actual pixelBarWrap width use:
  // const wrap = document.getElementById('pixelBarWrap'); const computedAvailable = (wrap? wrap.clientWidth : card.clientWidth) - 40;

  // compute how many blocks fit across the available width
  const segsFit = Math.floor((computedAvailable + gapPx) / (sizePx + gapPx));
  // clamp to min/max
  const segs = Math.max(minSegs, Math.min(maxSegs, segsFit || minSegs));

  // update CSS var (optional, keeps styling in sync)
  document.documentElement.style.setProperty('--segments', String(segs));

  // rebuild cells with px sizes passed (we pass sizePx & gapPx so buildPixelBar sets inline --size/--gap if it uses them)
  buildPixelBar(segs, Math.round(sizePx), Math.round(gapPx));
}

//  buildPixelBar(...) call:
adaptiveBuildPixelBar();

// Debounced resize to re-adapt
let _adaptResizeTimer = null;
window.addEventListener('resize', ()=> {
  clearTimeout(_adaptResizeTimer);
  _adaptResizeTimer = setTimeout(()=> adaptiveBuildPixelBar(), 140);
});



/* call setPixelProgress(pct) from updateDisplay() — I'll show exact place to change below. */


  function setMode(mode){
    timerState.mode = mode;
    resetMilestones();
    if(mode === 'work'){ timerState.remaining = timerState.workMin * 60; setFoxState('alert'); }
    if(mode === 'short'){ timerState.remaining = timerState.shortMin * 60; setFoxState('stretch'); }
    if(mode === 'long'){ timerState.remaining = timerState.longMin * 60; setFoxState('nap'); }
    updateDisplay(); // refresh UI
  }

function updateDisplay(){
  const mm = Math.floor(timerState.remaining/60).toString().padStart(2,'0');
  const ss = Math.floor(timerState.remaining%60).toString().padStart(2,'0');
  timeDisplay.textContent = `${mm}:${ss}`;
  sessionLabel.textContent = `Session ${timerState.sessionCount}`;

  // percent of current mode elapsed
  const total = (timerState.mode === 'work') ? timerState.workMin*60
              : (timerState.mode === 'short') ? timerState.shortMin*60
              : timerState.longMin*60;

  // compute pct exactly once
  const pct = Math.round( (1 - (timerState.remaining / total)) * 100 );
  percentLabel.textContent = `${pct}%`;

  // update pixel bar (safe if pixelBar missing)
  try { setPixelProgress(pct); } catch(e){ /* ignore */ }

  // milestone checks when working & running
  if(timerState.running && timerState.mode === 'work') onMilestone(pct);
}

  function tick(){
    if(!timerState.running) return;
    if(timerState.remaining <= 0){
      // session finished
      if(timerState.mode === 'work'){
        timerState.sessionCount++;
        // choose long every 4 sessions
        if(timerState.sessionCount % 4 === 0){
          setMode('long');
        } else {
          setMode('short');
        }
      } else {
        // break finished -> back to work
        setMode('work');
      }
      updateDisplay();
      return;
    }
    timerState.remaining--;
    updateDisplay();
  }

  /* ---------- start/pause, skip, reset controls ---------- */
  function startPause(){
    if(!timerState.running){
      timerState.running = true;
      if(!timerState.intervalId) timerState.intervalId = setInterval(tick,1000);
      mainLabel.textContent = 'Pause';
      mainAction.setAttribute('aria-pressed','true');
      // icon -> pause
      mainIcon.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
      // ensure mode is alert when starting work if currently neutral
      if(timerState.mode === 'work') setFoxState('alert');
    } else {
      timerState.running = false;
      mainLabel.textContent = 'Start';
      mainAction.setAttribute('aria-pressed','false');
      mainIcon.innerHTML = '<path d="M8 5v14l11-7z"/>';
      setFoxState('neutral');
      // keep running interval alive but paused; we clear for safety
      if(timerState.intervalId){ clearInterval(timerState.intervalId); timerState.intervalId = null; }
    }
  }

  function skipSession(){
    // fast-forward current session to its end
    timerState.remaining = 0;
    updateDisplay();
  }

  function resetAll(){
    timerState.running = false;
    if(timerState.intervalId){ clearInterval(timerState.intervalId); timerState.intervalId = null; }
    timerState.sessionCount = 0;
    setMode('work'); // reset to work mode with workMin
    setFoxState('neutral');
    mainLabel.textContent = 'Start';
    mainIcon.innerHTML = '<path d="M8 5v14l11-7z"/>';
  }
// toggle
settingsBtn.addEventListener('click', ()=>{
  const open = settingsPanel.classList.toggle('open');
  settingsBtn.setAttribute('aria-expanded', String(open));
  settingsPanel.setAttribute('aria-hidden', String(!open));
  if(open) settingsBtn.classList.add('open'); else settingsBtn.classList.remove('open');
});

/* inputs update durations
workInput.addEventListener('change', ()=> { loadFromInputs(); if(state.mode==='work') setMode('work'); });
shortInput.addEventListener('change', ()=> { loadFromInputs(); if(state.mode==='short') setMode('short'); });
longInput.addEventListener('change', ()=> { loadFromInputs(); if(state.mode==='long') setMode('long'); });*/

  // --- surgical listeners to apply settings immediately ---
// (place after your input element declarations / loadFromInputs function)

function applyNewDuration(modeKey, newMin){
  newMin = Math.max(1, parseInt(newMin, 10) || 1);
  // find old total for current mode to preserve progress fraction
  const oldTotal = (modeKey === 'work') ? timerState.workMin*60
                 : (modeKey === 'short') ? timerState.shortMin*60
                 : timerState.longMin*60;

  // percent elapsed so far (use 0 if oldTotal is 0)
  const elapsedPct = oldTotal ? (1 - (timerState.remaining / oldTotal)) : 0;

  // commit new minutes
  if(modeKey === 'work') timerState.workMin = newMin;
  if(modeKey === 'short') timerState.shortMin = newMin;
  if(modeKey === 'long') timerState.longMin = newMin;

  // compute new remaining so the same fraction of progress is kept
  const newTotal = (modeKey === 'work') ? timerState.workMin*60
                 : (modeKey === 'short') ? timerState.shortMin*60
                 : timerState.longMin*60;

  // If the mode changed is current mode, scale remaining; otherwise leave remaining alone
  if(timerState.mode === modeKey){
    // keep the same elapsedPct (clamp 0..1)
    const pct = Math.max(0, Math.min(1, elapsedPct));
    timerState.remaining = Math.max(1, Math.round((1 - pct) * newTotal));
  }

  // refresh UI
  updateDisplay();
}

// attach listeners
workInput.addEventListener('change', (e)=> { applyNewDuration('work', e.target.value); });
shortInput.addEventListener('change', (e)=> { applyNewDuration('short', e.target.value); });
longInput.addEventListener('change', (e)=> { applyNewDuration('long', e.target.value); });

/*End input update*/
  /* ---------- initial setup ---------- */
  loadInputsDefaults();
  setMode('work'); // initialize mode -> sets fox and remaining
  setFoxState('neutral'); // start neutral visually until Start pressed
  updateDisplay();

  /* ---------- wire UI actions ---------- */
  mainAction.addEventListener('click', ()=> {
    startPause();
  });
  skipBtn.addEventListener('click', ()=> {
    skipSession();
  });
  resetBtn.addEventListener('click', ()=> {
    resetAll();
  });

  /* ---------- quick preload of images (optional but useful) ---------- */
(function preload(){
  const urls = [];
  Object.values(foxFrames).forEach(group=>{
    Object.values(group).forEach(v=>{
      if(Array.isArray(v)) v.forEach(x=>urls.push(x));
      else urls.push(v);
    });
  });

  // create <img> nodes (hidden until their file loads)
  let neutralLoaded = false;
  let loadedCount = 0;
  const total = urls.length;
  const timeoutMs = 1500; // fallback if network slow

  urls.forEach(u=>{
    if(!foxEl.querySelector(`img[data-src="${u}"]`)){
      const img = document.createElement('img');
      img.src = u;
      img.dataset.src = u;
      img.alt = '';
      img.draggable = false;
      img.decoding = 'async';
      img.style.visibility = 'hidden';    // hide until loaded
      img.addEventListener('load', ()=>{
        loadedCount++;
        img.style.visibility = 'visible';
        if(!neutralLoaded && u === foxFrames.neutral.base){
          neutralLoaded = true;
          setFox(foxFrames.neutral.base);
          setLine(random(foxFrames.neutral.lines));
          foxEl.setAttribute('aria-hidden', 'false');
        }
        if(loadedCount === total && !neutralLoaded){
          neutralLoaded = true;
          setFox(foxFrames.neutral.base);
          setLine(random(foxFrames.neutral.lines));
          foxEl.setAttribute('aria-hidden', 'false');
        }
      });
      setTimeout(()=>{
        if(!neutralLoaded && u === foxFrames.neutral.base){
          neutralLoaded = true;
          setFox(foxFrames.neutral.base);
          setLine(random(foxFrames.neutral.lines));
          foxEl.setAttribute('aria-hidden', 'false');
        }
      }, timeoutMs);

      foxEl.appendChild(img);
    }
  });

  const neutralImg = foxEl.querySelector(`img[data-src="${foxFrames.neutral.base}"]`);
  if(neutralImg && neutralImg.complete){
    neutralImg.style.visibility = 'visible';
    if(!neutralLoaded){
      neutralLoaded = true;
      setFox(foxFrames.neutral.base);
      setLine(random(foxFrames.neutral.lines));
      foxEl.setAttribute('aria-hidden', 'false');
    }
  }
})();



}); // DOMContentLoaded
</script>
</body>
</html>
